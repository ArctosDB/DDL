--from https://github.com/ArctosDB/arctos/issues/983
-- actually nevermind - this isn't necessary, nobody will want to claim it, no need to have any constraints, treat it like the stuff from GN
--insert into  CTTAXONOMY_SOURCE (SOURCE,DESCRIPTION) values ('Arctos Relationships','Place to store related taxon data in classifications as a search aid. These data are not an authoritative taxonomy source.');
--delete from CTTAXONOMY_SOURCE where source='Arctos Relationships';
-- ignore that in triggers


create or replace trigger trg_taxon_term_cts....

-- seed with existing data

alter table taxon_relations add stale_fg number;


update taxon_relations set stale_fg=1 where taxon_name_id=36;

-- delete and replace relationships FROM one name
-- this will be called for both IDs for each relationship
CREATE OR REPLACE PROCEDURE proc_ref_taxon_relation_oneway 
	(
		tid IN number
	)
	IS
	
	
		see /procedures/taxon_relations.sql

		
		
		
	--	temp varchar2(4000);
		cid varchar2(255);
begin
	--dbms_output.put_line(tid);
	--dbms_output.put_line('deleting all "Arctos Relationships" classifications FROM ' || tid);
	delete from taxon_term where source='Arctos Relationships' and taxon_name_id=tid;
	--dbms_output.put_line('rebuilding all "Arctos Relationships" classifications FROM ' || tid);
	-- get all related IDs
	for r in (select RELATED_TAXON_NAME_ID,TAXON_RELATIONSHIP,RELATION_AUTHORITY from taxon_relations where TAXON_NAME_ID=tid) loop
		-- for each of those, create the FROM relationship 
		for relt in (
			select 
				classification_id, 
				source 
			from 
				taxon_term 
			where 
				taxon_name_id=r.related_taxon_name_id and
				source in (select source from cttaxonomy_source)
			group by classification_id, source
		) loop
			--dbms_output.put_line('insert for relt.classification_id::' || relt.classification_id);
			select sys_guid() into cid from dual;
			--dbms_output.put_line('got a guid');
			insert into taxon_term (
				TAXON_NAME_ID,
				CLASSIFICATION_ID,
				TERM,
				TERM_TYPE,
				SOURCE,
				POSITION_IN_CLASSIFICATION
			) (
				select distinct
					tid,
					cid,
					term,
					term_type,
					'Arctos Relationships',
					POSITION_IN_CLASSIFICATION
				from
					taxon_term
				where
					classification_id=relt.classification_id
			);
			insert into taxon_term (
				TAXON_NAME_ID,
				CLASSIFICATION_ID,
				TERM,
				TERM_TYPE,
				SOURCE
			) values (
				tid,
				cid,
				'Autogenerated from relationship "' || r.TAXON_RELATIONSHIP || '."' || decode(r.RELATION_AUTHORITY,NULL,'',' Authority: ' || r.RELATION_AUTHORITY) || '. Source Classification: ' || relt.source,
				'remark',
				'Arctos Relationships'
			);
			
		end loop;
	end loop;
end;
/
sho err;

exec proc_ref_taxon_relation_oneway(36);



update taxon_relations set stale_fg=1 where taxon_name_id=10954363;

CREATE OR REPLACE PROCEDURE proc_ref_taxon_relations IS

	see /procedures/taxon_relations.sql

	
	
	cid varchar2(4000);
	temp varchar2(4000);
begin
	-- from https://github.com/ArctosDB/arctos/issues/1866
	-- added last_refresh_date
	-- if it's NULL, and the relationship is not already flagged for update, the relationship should be flagged as stale
	update taxon_relations set stale_fg=1 where last_refresh_date is null and stale_fg!=1;
	-- if it's older than 6 months, and the relationship is not already flagged for update, the relationship should be flagged as stale
	update taxon_relations set stale_fg=1 where last_refresh_date <= TRUNC(SYSDATE) - 180 and stale_fg!=1;
	-- now on to your regularly scheduled refresh
	for r in (select distinct taxon_name_id from taxon_relations where stale_fg=1 and rownum<50) loop
		-- update the anchor
		--dbms_output.put_line('refreshing anchor: ' || r.taxon_name_id);
		proc_ref_taxon_relation_oneway(r.taxon_name_id);
		--- now get ALL related IDs
		-- update them and reset stale flag; 
		  --it's probably only one of them which caused this.
		  -- the loop will get that one, along with everything else involved
		for relns in (select * from taxon_relations where taxon_name_id=r.taxon_name_id) loop
			--dbms_output.put_line('refreshing related term: ' || relns.related_taxon_name_id);
			proc_ref_taxon_relation_oneway(relns.related_taxon_name_id);
			--dbms_output.put_line('marking relationship refreshed: ' || relns.TAXON_RELATIONS_ID);
			update taxon_relations set last_refresh_date=sysdate,stale_fg=0 where TAXON_RELATIONS_ID = relns.TAXON_RELATIONS_ID;
		end loop;
	end loop;
end;
/
sho err;


exec proc_ref_taxon_relations;


select stale_fg,count(*) from taxon_relations group by stale_fg;




----------------------------------------------------------------------------------------------
-- https://github.com/ArctosDB/arctos/issues/1866
-- add a timestamp to taxon_relations
alter table taxon_relations add last_refresh_date date;
create index ix_tax_rel_stl_fg on taxon_relations(stale_fg) tablespace uam_idx_1;
-- updating maybe-NULL dates is expensive; we can't do it in the trigger.
-- update them to something random

-- updated

-- anything with a NULL last_refresh_date needs dealt with
-- then anything older than 6 months

UAM@ARCTOS> desc taxon_relations
 Name								   Null?    Type
 ----------------------------------------------------------------- -------- --------------------------------------------
 TAXON_NAME_ID							   NOT NULL NUMBER(10)
 RELATED_TAXON_NAME_ID						   NOT NULL NUMBER(10)
 TAXON_RELATIONSHIP						   NOT NULL VARCHAR2(50)
 RELATION_AUTHORITY							    VARCHAR2(255)
 TAXON_RELATIONS_ID						   NOT NULL NUMBER
 STALE_FG								    NUMBER








update taxon_relations set stale_fg=1 where taxon_relations_id=106791;
update taxon_relations set stale_fg=1 where taxon_name_id=1890360;




select scientific_name  from taxon_name where taxon_name_id=11243055;
Cepola indica
select scientific_name  from taxon_name where taxon_name_id=1890360;
Acanthocepola limbata

















UAM@ARCTOS> select taxon_name_id from taxon_name where scientific_name='Cepola indica';

TAXON_NAME_ID
-------------
     11243055

     
      2002152		    
     
    Elapsed: 00:00:00.01
UAM@ARCTOS> select * from taxon_relations where taxon_name_id=11243055;

TAXON_NAME_ID RELATED_TAXON_NAME_ID
------------- ---------------------
TAXON_RELATIONSHIP
------------------------------------------------------------------------------------------------------------------------
RELATION_AUTHORITY
------------------------------------------------------------------------------------------------------------------------
TAXON_RELATIONS_ID   STALE_FG
------------------ ----------
     11243055		    2002152
synonym of
WoRMS
	    296361	    0


	    
	    



select scientific_name from taxon_name, taxon_term where taxon_name.taxon_name_id=taxon_term.taxon_name_id and taxon_term.source='Arctos Relationships' group by scientific_name order by scientific_name;

select a.taxon_name_id from taxon_term a, taxon_term b, taxon_term c
where a.taxon_Name_id=b.taxon_name_id and a.taxon_Name_id=c.taxon_name_id and
a.source='Arctos' and b.source='Arctos Plants' and c.source='Arctos Relationships'
group by a.taxon_name_id;


select stale_fg,count(*) from taxon_relations group by stale_fg;

  STALE_FG   COUNT(*)
---------- ----------
	 1    1022694
	 0	 6829

	 
	 
Elapsed: 00:00:00.00
UAM@ARCTOSTE> 

select stale_fg,count(*) from taxon_relations group by stale_fg;

  STALE_FG   COUNT(*)
---------- ----------
		  220
	 1     274007
	 0	10776

  STALE_FG   COUNT(*)
---------- ----------
		  220
	 1     283987
	 0	  796


exec proc_ref_taxon_relations;
-- this can probably drop to daily or hourly or something after we're caught up
-- for now, every minute
BEGIN
	see /procedures/taxon_relations.sql
DBMS_SCHEDULER.CREATE_JOB (
   job_name           =>  'j_proc_ref_taxon_relations',
   job_type           =>  'STORED_PROCEDURE',
   job_action         =>  'proc_ref_taxon_relations',
   start_date         =>  SYSTIMESTAMP,
   repeat_interval    =>  'freq=MINUTELY',
   enabled             =>  TRUE,
   end_date           =>  NULL,
   comments           =>  'push taxon relations to classifications');
END;
/

select STATE,LAST_START_DATE,NEXT_RUN_DATE,LAST_RUN_DURATION from all_scheduler_jobs where lower(JOB_NAME)='j_proc_ref_taxon_relations';

exec DBMS_SCHEDULER.DROP_JOB (JOB_NAME => 'j_proc_ref_taxon_relations', FORCE => TRUE);


update taxon_relations set stale_fg=1 where TAXON_RELATIONS_ID in (select TAXON_RELATIONS_ID from temp_tax_rel where pushed_to_class is null);




--delete from taxon_term where source='Arctos Relationships';











CREATE OR REPLACE PROCEDURE proc_ref_taxon_relations__old IS
	cid varchar2(4000);
	temp varchar2(4000);
begin
	for r in (select * from taxon_relations where 
		stale_fg=1 and rownum<250 
		--TAXON_name_ID=36
		) loop
		-- just delete ALL existing relationship classifications for both the originating and related names
		-- deleting all doesn't work on things with multiple relationships
		-- TAXON_name_ID=36 = wolf is good example
		-- delete only the single
		
		select scientific_name into temp from taxon_name where taxon_name_id=r.taxon_name_id;
		dbms_output.put_line('deleting Arctos Relationships for ' || r.taxon_name_id || '=' || temp);
		delete from taxon_term where source='Arctos Relationships' and taxon_name_id=r.taxon_name_id;
		select scientific_name into temp from taxon_name where taxon_name_id=r.related_taxon_name_id;
		dbms_output.put_line('deleting Arctos Relationships for ' || r.related_taxon_name_id || '=' || temp);
		delete from taxon_term where source='Arctos Relationships' and taxon_name_id=r.related_taxon_name_id;
	
		-- insert for TAXON_NAME_ID
		
		--dbms_output.put_line('taxon_name_id::' || r.taxon_name_id);
		--dbms_output.put_line('TAXON_RELATIONS_ID::'||r.TAXON_RELATIONS_ID);
		
		-- insert for EACH local classification in related_taxon_name_id
		for relt in (
			select 
				classification_id, 
				source 
			from 
				taxon_term 
			where 
				taxon_name_id=r.related_taxon_name_id and
				source in (select source from cttaxonomy_source)
			group by classification_id, source
		) loop
			dbms_output.put_line('insert for relt.classification_id::' || relt.classification_id);
			select sys_guid() into cid from dual;
			dbms_output.put_line('got a guid');
			insert into taxon_term (
				TAXON_NAME_ID,
				CLASSIFICATION_ID,
				TERM,
				TERM_TYPE,
				SOURCE,
				POSITION_IN_CLASSIFICATION
			) (
				select distinct
					r.taxon_name_id,
					cid,
					term,
					term_type,
					'Arctos Relationships',
					POSITION_IN_CLASSIFICATION
				from
					taxon_term
				where
					classification_id=relt.classification_id
			);
			insert into taxon_term (
				TAXON_NAME_ID,
				CLASSIFICATION_ID,
				TERM,
				TERM_TYPE,
				SOURCE
			) values (
				r.taxon_name_id,
				cid,
				'Autogenerated from relationship "' || r.TAXON_RELATIONSHIP || '."' || decode(r.RELATION_AUTHORITY,NULL,'',' Authority: ' || r.RELATION_AUTHORITY) || '. Source Classification: ' || relt.source,
				'remark',
				'Arctos Relationships'
			);
			
		end loop;
		-- insert for EACH local classification in taxon_name_id
		for relt_r in (
			select 
				classification_id, 
				source 
			from 
				taxon_term 
			where 
				taxon_name_id=r.taxon_name_id and
				source in (select source from cttaxonomy_source)
			group by classification_id, source
		) loop
			dbms_output.put_line('relt_r.classification_id::' || relt_r.classification_id);
			select sys_guid() into cid from dual;
			insert into taxon_term (
				TAXON_NAME_ID,
				CLASSIFICATION_ID,
				TERM,
				TERM_TYPE,
				SOURCE,
				POSITION_IN_CLASSIFICATION
			) (
				select distinct
					r.related_taxon_name_id,
					cid,
					term,
					term_type,
					'Arctos Relationships',
					POSITION_IN_CLASSIFICATION
				from
					taxon_term
				where
					classification_id=relt_r.classification_id
			);
			insert into taxon_term (
				TAXON_NAME_ID,
				CLASSIFICATION_ID,
				TERM,
				TERM_TYPE,
				SOURCE
			) values (
				r.related_taxon_name_id,
				cid,
				'Autogenerated from relationship "' || r.TAXON_RELATIONSHIP || '."' || decode(r.RELATION_AUTHORITY,NULL,'',' Authority: ' || r.RELATION_AUTHORITY) || '. Source Classification: ' || relt_r.source,
				'remark',
				'Arctos Relationships'
			);
			
			
		end loop;
		update taxon_relations set stale_fg=0 where TAXON_RELATIONS_ID=r.TAXON_RELATIONS_ID;

	end loop;
end;
/
sho err;