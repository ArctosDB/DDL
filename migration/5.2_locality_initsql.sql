-- Untested and commented initial SQL attempt.
-- This file exists as a static temporary document with which to solicit comments.
-- DO NOT EDIT THIS FILE
-- merge changes/updates back into 5.2_locality.sql

-- create functions to convert coordinates to strings in hopefully-standardized ways
-- store verbatim coordinates as strings rather than structured data to improve flexibility,
-- reduce complexity

CREATE OR REPLACE FUNCTION utm_to_string (
    UTM_NS IN VARCHAR2,
    UTM_EW IN VARCHAR2,
    UTM_ZONE IN VARCHAR2
    ) return varchar2 as 
        rval varchar2(4000);
   begin
       rval := UTM_NS || 'N ' || UTM_EW || 'E ZONE ' || nvl(UTM_ZONE,'not recorded');
       RETURN rval;
   END;
/

CREATE PUBLIC SYNONYM utm_to_string FOR utm_to_string;
GRANT EXECUTE ON utm_to_string TO PUBLIC;

CREATE OR REPLACE FUNCTION dd_to_string (
    dd_lat IN VARCHAR2,
    dd_long IN VARCHAR2
 ) return varchar2 as
       rval varchar2(4000);
   begin
       rval := dd_lat || '/' || dd_long;
       RETURN rval;
   END;
/

CREATE PUBLIC SYNONYM dd_to_string FOR dd_to_string;
GRANT EXECUTE ON dd_to_string TO PUBLIC;

CREATE OR REPLACE FUNCTION dm_to_string (
    d_lat IN VARCHAR2,
    m_lat IN VARCHAR2,
    dir_lat IN VARCHAR2,
    d_long IN VARCHAR2,
    m_long IN VARCHAR2,
    dir_long  IN VARCHAR2
    ) return varchar2 as
       rval varchar2(4000);
   begin
       rval := d_lat || 'd ' || m_lat || 'm ' || upper(dir_lat) || '/' || d_long || 'd ' || m_long || 'm ' || upper(dir_long);
       RETURN rval;
   END;
/

CREATE PUBLIC SYNONYM dm_to_string FOR dm_to_string;
GRANT EXECUTE ON dm_to_string TO PUBLIC;

CREATE OR REPLACE FUNCTION dms_to_string (
    d_lat IN VARCHAR2,
    m_lat IN VARCHAR2,
    s_lat IN VARCHAR2,
    dir_lat IN VARCHAR2,
    d_long IN VARCHAR2,
    m_long IN VARCHAR2,
    s_long  IN VARCHAR2,
    dir_long  IN VARCHAR2
    ) return varchar2 as
       rval varchar2(4000);
   BEGIN
       rval := d_lat || 'd ' || m_lat || 'm ' || s_lat || 's ' ||upper(dir_lat) || '/' || d_long || 'd ' || m_long || 'm ' || s_long || 's ' ||upper(dir_long);
       RETURN rval;
   END;
/

CREATE PUBLIC SYNONYM dms_to_string FOR dms_to_string;
GRANT EXECUTE ON dms_to_string TO PUBLIC;

-- a big giant temp table to smooth things along
-- keep everything - every locality_id and collecting_event_id will survive this migration. Do some heavy weeding after we're settled, perhaps.
-- perform all manipulations, new key creation, etc. here
-- then push it out before allowing anyone else in the DB
-- this includes all specimen-habitat, specimen-event-locality, event, and locality data. Unaccepted coordinates end up
-- as new rows, as they are in the new model

CREATE TABLE 
    everything_locality 
AS SELECT
    cataloged_item.COLLECTION_OBJECT_ID,
    coll_object_remark.HABITAT,
    collecting_event.COLLECTING_EVENT_ID,
    collecting_event.VERBATIM_DATE,
    collecting_event.VERBATIM_LOCALITY,
    collecting_event.COLL_EVENT_REMARKS,
    collecting_event.COLLECTING_SOURCE,
    collecting_event.COLLECTING_METHOD,
    collecting_event.HABITAT_DESC,
    collecting_event.BEGAN_DATE,
    collecting_event.ENDED_DATE,
    locality.LOCALITY_ID,
    locality.MAXIMUM_ELEVATION,
    locality.MINIMUM_ELEVATION,
    locality.ORIG_ELEV_UNITS,
    locality.SPEC_LOCALITY,
    locality.LOCALITY_REMARKS,
    locality.DEPTH_UNITS,
    locality.MIN_DEPTH,
    locality.MAX_DEPTH,
    locality.NOGEOREFBECAUSE,
    locality.GEOG_AUTH_REC_ID,
    lat_long.LAT_LONG_ID,
    lat_long.LAT_DEG,
    lat_long.DEC_LAT_MIN,
    lat_long.LAT_MIN,
    lat_long.LAT_SEC,
    lat_long.LAT_DIR,
    lat_long.LONG_DEG,
    lat_long.DEC_LONG_MIN,
    lat_long.LONG_MIN,
    lat_long.LONG_SEC,
    lat_long.LONG_DIR,
    lat_long.DEC_LAT,
    lat_long.DEC_LONG,
    lat_long.DATUM,
    lat_long.UTM_ZONE,
    lat_long.UTM_EW,
    lat_long.UTM_NS,
    lat_long.ORIG_LAT_LONG_UNITS,
    lat_long.DETERMINED_BY_AGENT_ID,
    lat_long.DETERMINED_DATE,
    lat_long.LAT_LONG_REF_SOURCE,
    lat_long.LAT_LONG_REMARKS,
    lat_long.MAX_ERROR_DISTANCE,
    lat_long.MAX_ERROR_UNITS,
    lat_long.ACCEPTED_LAT_LONG_FG,
    lat_long.EXTENT,
    lat_long.GPSACCURACY,
    lat_long.GEOREFMETHOD,
    lat_long.VERIFICATIONSTATUS
FROM
    locality,
    lat_long,
    collecting_event,
    cataloged_item,
    coll_object_remark
WHERE
   locality.locality_id=lat_long.locality_id (+) AND
   locality.locality_id=collecting_event.locality_id (+) AND
   collecting_event.collecting_event_id=cataloged_item.collecting_event_id (+) AND
   cataloged_item.collection_object_id=coll_object_remark.collection_object_id (+)
   ;
   
   
-- recycle locality_id for accepted coordinates and no coordinates records. These will be "where collected" specimen_event_types.
-- Media etc. uses only these IDs

ALTER TABLE everything_locality ADD new_locality_id NUMBER;

UPDATE everything_locality SET new_locality_id=locality_id WHERE LAT_LONG_ID IS NULL;
UPDATE everything_locality SET new_locality_id=locality_id WHERE ACCEPTED_LAT_LONG_FG=1;

-- these are "unaccepted" in the old and new models. The IDs aren't used, so just grab next available values
BEGIN
    FOR r IN (SELECT locality_id FROM everything_locality WHERE new_locality_id IS NULL GROUP BY locality_id) LOOP
        UPDATE everything_locality SET new_locality_id=sq_locality_id.nextval WHERE locality_id=r.locality_id;
    END LOOP;
END;
/

-- same thing for collecting events
ALTER TABLE everything_locality ADD new_collecting_event_id NUMBER;

UPDATE everything_locality SET new_collecting_event_id=collecting_event_id WHERE LAT_LONG_ID IS NULL;
UPDATE everything_locality SET new_collecting_event_id=collecting_event_id WHERE ACCEPTED_LAT_LONG_FG=1;
BEGIN
    FOR r IN (SELECT collecting_event_id FROM everything_locality WHERE new_collecting_event_id IS NULL GROUP BY collecting_event_id) LOOP
        UPDATE everything_locality SET new_collecting_event_id=sq_collecting_event_id.nextval WHERE collecting_event_id=r.collecting_event_id;
    END LOOP;
END;
/

-- combine habitat data
ALTER TABLE everything_locality ADD merged_habitat VARCHAR2(4000);

UPDATE everything_locality SET merged_habitat = HABITAT WHERE HABITAT IS NOT NULL AND HABITAT_DESC IS NULL;
UPDATE everything_locality SET merged_habitat = HABITAT_DESC WHERE HABITAT_DESC IS NOT NULL AND HABITAT IS NULL;
UPDATE everything_locality SET merged_habitat = HABITAT_DESC || '; ' || HABITAT WHERE HABITAT_DESC IS NOT NULL AND HABITAT IS NOT NULL;


ALTER TABLE everything_locality ADD verbatim_coordinates VARCHAR2(4000);
UPDATE everything_locality SET verbatim_coordinates = utm_to_string(UTM_NS,UTM_EW,UTM_ZONE) WHERE ORIG_LAT_LONG_UNITS='UTM';
UPDATE everything_locality SET verbatim_coordinates = dd_to_string(dec_lat,dec_long) WHERE ORIG_LAT_LONG_UNITS='decimal degrees';
UPDATE everything_locality SET verbatim_coordinates = dm_to_string(
        LAT_DEG,
        DEC_LAT_MIN,
        LAT_DIR,
        LONG_DEG,
        DEC_LONG_MIN,
        LONG_DIR
    ) WHERE
   ORIG_LAT_LONG_UNITS='degrees dec. minutes';
   
   
UPDATE everything_locality SET verbatim_coordinates = dms_to_string(
        LAT_DEG,
        LAT_MIN,
        LAT_SEC,
        LAT_DIR,
        LONG_DEG,
        LONG_MIN,
        LONG_SEC,
        LONG_DIR
    ) WHERE  ORIG_LAT_LONG_UNITS='deg. min. sec.';

-- link between specimens and events
ALTER TABLE everything_locality ADD specimen_event_type VARCHAR2(4000);

-- no control over these things
-- a specimen can have no accepted event, or lots of accepted events, or anything else.

-- no coordinates = accepted
UPDATE everything_locality SET specimen_event_type='accepted place of collection' WHERE LAT_LONG_ID IS NULL;
-- accepted coordinates = accepted
UPDATE everything_locality SET specimen_event_type='accepted place of collection' WHERE ACCEPTED_LAT_LONG_FG=1;
-- unaccepted coordinates = unaccepted
UPDATE everything_locality SET specimen_event_type='unaccepted place of collection' WHERE ACCEPTED_LAT_LONG_FG=0;

-- reclaim UAM Insects collecting method data from attributes

BEGIN
    FOR r IN (SELECT COLLECTION_OBJECT_ID, ATTRIBUTE_VALUE FROM attributes WHERE ATTRIBUTE_TYPE='collecting method') LOOP
      UPDATE  everything_locality SET COLLECTING_METHOD=r.ATTRIBUTE_VALUE WHERE COLLECTION_OBJECT_ID=r.COLLECTION_OBJECT_ID;
    END LOOP;
END;
/
             
-- new TABLE definitions, rename old for backup
                                   
CREATE TABLE ctspecimen_event_type (
    specimen_event_type VARCHAR2(60) NOT NULL,
    description VARCHAR2(255) NOT NULL
);

-- can have any number of these, but these two (which can get better names any time now) deal with legacy data

INSERT INTO ctspecimen_event_type (specimen_event_type,description) VALUES (
    'accepted place of collection',
    'Place where a specimen was removed from the wild. Also legacy migration target for accepted coordinate determination.'
);
INSERT INTO ctspecimen_event_type (specimen_event_type,description) VALUES (
    'unaccepted place of collection',
    'Place where a specimen was removed from the wild, deemed incorrect by curatorial staff. Also legacy migration target for unaccepted coordinate determination.'
);

CREATE PUBLIC SYNONYM ctspecimen_event_type FOR ctspecimen_event_type;
GRANT ALL ON ctspecimen_event_type TO manage_codetables;
GRANT SELECT ON ctspecimen_event_type TO PUBLIC;

ALTER TABLE ctspecimen_event_type ADD CONSTRAINT pk_ctspecimen_event_type PRIMARY KEY (specimen_event_type) USING INDEX TABLESPACE UAM_IDX_1;

CREATE SEQUENCE sq_specimen_event_id;
CREATE PUBLIC SYNONYM sq_specimen_event_id FOR sq_specimen_event_id;
GRANT SELECT ON sq_specimen_event_id TO PUBLIC;

CREATE TABLE SPECIMEN_EVENT (
    SPECIMEN_EVENT_ID NUMBER NOT NULL,
    collection_object_id NUMBER NOT NULL,
    collecting_event_id NUMBER NOT NULL,
    assigned_by_agent_id NUMBER NOT NULL,
    assigned_date DATE NOT NULL,
    specimen_event_remark VARCHAR2(4000),
    specimen_event_type VARCHAR2(60) NOT NULL,
    COLLECTING_METHOD VARCHAR2(255),
    COLLECTING_SOURCE VARCHAR2(60),
    VERIFICATIONSTATUS VARCHAR2(60) NOT NULL,
    habitat  VARCHAR2(4000)
);

CREATE PUBLIC SYNONYM SPECIMEN_EVENT FOR SPECIMEN_EVENT;
GRANT ALL ON SPECIMEN_EVENT TO manage_specimens;

CREATE OR REPLACE TRIGGER trg_SPECIMEN_EVENT_biu
    BEFORE INSERT OR UPDATE ON SPECIMEN_EVENT
    FOR EACH ROW
    BEGIN
        if :new.SPECIMEN_EVENT_ID is null then
        	select sq_specimen_event_id.nextval into :new.SPECIMEN_EVENT_ID from dual;
        end if;
        if :new.VERIFICATIONSTATUS is null then
        	:new.VERIFICATIONSTATUS:='unverified';
        end if;
        if :new.specimen_event_type is null then
        	:new.specimen_event_type:='accepted place of collection';
        end if;
    end;
/

ALTER TABLE SPECIMEN_EVENT ADD CONSTRAINT pk_SPECIMEN_EVENT PRIMARY KEY (SPECIMEN_EVENT_id) USING INDEX TABLESPACE UAM_IDX_1;
ALTER TABLE SPECIMEN_EVENT add CONSTRAINT fk_SPECIMEN_EVENT_catitem FOREIGN KEY (collection_object_id) REFERENCES cataloged_item (collection_object_id);		    
ALTER TABLE SPECIMEN_EVENT add CONSTRAINT fk_SPECIMEN_EVENT_collevent FOREIGN KEY (collecting_event_id) REFERENCES collecting_event (collecting_event_id);		    
ALTER TABLE SPECIMEN_EVENT add CONSTRAINT fk_SPECIMEN_EVENT_agent FOREIGN KEY (assigned_by_agent_id) REFERENCES agent (agent_id);	    
ALTER TABLE SPECIMEN_EVENT add CONSTRAINT fk_SPECIMEN_EVENT_ctsetype FOREIGN KEY (specimen_event_type) REFERENCES ctspecimen_event_type (specimen_event_type);
ALTER TABLE SPECIMEN_EVENT add CONSTRAINT fk_SPECIMEN_EVENT_ctvstatus FOREIGN KEY (VERIFICATIONSTATUS) REFERENCES ctVERIFICATIONSTATUS (VERIFICATIONSTATUS);
ALTER TABLE SPECIMEN_EVENT add CONSTRAINT fk_SPECIMEN_EVENT_ctcsource FOREIGN KEY (COLLECTING_SOURCE) REFERENCES ctCOLLECTING_SOURCE (COLLECTING_SOURCE);

-- bye bye, existing table collecting_event....	
ALTER TABLE collecting_event RENAME TO collecting_event_old;

-- keep coordinates broken out in new collecting_event for now - would like to get rid of these, but
-- need the datum conversion thing working first. Craps....
-- Throw calculated un-datum-converted dec lat/long in here too - this will
-- get submerged into the datum conversion process, wherever that ends up,
-- should such a thing ever actually exist

CREATE TABLE collecting_event (
    COLLECTING_EVENT_ID NUMBER NOT NULL,
    LOCALITY_ID NUMBER NOT NULL,
    VERBATIM_DATE VARCHAR2(60),
    VERBATIM_LOCALITY VARCHAR2(4000),
    COLL_EVENT_REMARKS VARCHAR2(4000),
    BEGAN_DATE VARCHAR2(22),
    ENDED_DATE VARCHAR2(22),                            
    verbatim_coordinates VARCHAR2(255),
    collecting_event_name VARCHAR2(255),
    LAT_DEG NUMBER,
    DEC_LAT_MIN NUMBER(8,6),
    LAT_MIN NUMBER,
    LAT_SEC NUMBER(8,6),
    LAT_DIR CHAR(1)
    LONG_DEG NUMBER,
    DEC_LONG_MIN NUMBER(10,8),
    LONG_MIN NUMBER,
    LONG_SEC NUMBER(8,6),
    LONG_DIR CHAR(1),
    DEC_LAT NUMBER(12,10),
    DEC_LONG  NUMBER(13,10),
    DATUM VARCHAR2(55),
    UTM_ZONE VARCHAR2(3),
    UTM_EW NUMBER,
    UTM_NS NUMBER,
    ORIG_LAT_LONG_UNITS VARCHAR2(20),
    caclulated_dlat NUMBER(12,10),
    calculated_dlong  NUMBER(13,10)
);
                          
CREATE PUBLIC SYNONYM collecting_event FOR collecting_event;
GRANT ALL ON collecting_event TO manage_locality;

CREATE OR REPLACE TRIGGER trg_collecting_event_biu
    BEFORE INSERT OR UPDATE ON collecting_event
    FOR EACH ROW
    BEGIN
        :new.caclulated_dlat := '';
        :new.calculated_dlong := '';
         
        if :new.COLLECTING_EVENT_ID is null then
        	select sq_COLLECTING_EVENT_ID.nextval into :new.COLLECTING_EVENT_ID from dual;
        end if;
            -- this IS ALL SORT OF stoopid lacking datum AND UTM conversion capabilities, but here it IS anyway...
            -- keep populating verbatim_coordinates, even while we're keeping the explicit fields,
            -- for display/future purposes
        IF :new.orig_lat_long_units = 'deg. min. sec.' THEN
        	:new.caclulated_dlat := :new.lat_deg + (:new.lat_min / 60) + (nvl(:new.lat_sec,0) / 3600);
            IF :new.lat_dir = 'S' THEN
                :new.caclulated_dlat := :new.caclulated_dlat * -1;
            END IF;
            :new.calculated_dlong := :new.long_deg + (:new.long_min / 60) + (nvl(:new.long_sec,0) / 3600);
            IF :new.long_dir = 'W' THEN
                :new.calculated_dlong := :new.calculated_dlong * -1;
            END IF;
            :new.verbatim_coordinates := dms_to_string (
                :new.lat_deg,
                :new.lat_min,
                :new.lat_sec,
                :new.lat_dir,
                :new.long_deg,
                :new.long_min,
                :new.long_sec,
                :new.long_dir
             )
        ELSIF :new.orig_lat_long_units = 'degrees dec. minutes' THEN
        	:new.caclulated_dlat := :new.lat_deg + (:new.dec_lat_min / 60);
        	if :new.lat_dir = 'S' THEN
        		:new.caclulated_dlat := :new.caclulated_dlat * -1;
        	end if;
        	:new.calculated_dlong := :new.long_deg + (:new.dec_long_min / 60);
        	IF :new.long_dir = 'W' THEN
        		:new.calculated_dlong := :new.calculated_dlong * -1;
        	END IF;
        	:new.verbatim_coordinates := dm_to_string (
                :new.lat_deg,
                :new.dec_lat_min,
                :new.lat_dir,
                :new.long_deg,
                :new.dec_long_min,
                :new.long_dir
             )
       ELSIF :new.orig_lat_long_units = 'decimal degrees' THEN
           :new.caclulated_dlat := :new.DEC_LAT;
           :new.calculated_dlong := :new.DEC_LONG;
           :new.verbatim_coordinates := dd_to_string (
                :new.DEC_LAT,
                :new.DEC_LONG
             );
       ELSIF :new.orig_lat_long_units = 'UTM' THEN
            :new.verbatim_coordinates := utm_to_string (
                :new.UTM_NS,
                :new.UTM_EW,
                :new.UTM_ZONE
            );
       END IF;   
    end;
/

ALTER TABLE collecting_event ADD CONSTRAINT pk_collecting_event PRIMARY KEY (collecting_event_id) USING INDEX TABLESPACE UAM_IDX_1;
ALTER TABLE collecting_event add CONSTRAINT fk_collecting_event_locality FOREIGN KEY (LOCALITY_ID) REFERENCES LOCALITY (LOCALITY_ID);		    


ALTER TABLE locality RENAME TO locality_old;

CREATE TABLE locality (
    locality_id NUMBER NOT NULL,
    GEOG_AUTH_REC_ID NUMBER NOT NULL,
    SPEC_LOCALITY VARCHAR2(255),
    DEC_LAT NUMBER (12,10),
    DEC_LONG NUMBER(13,10),
    MINIMUM_ELEVATION NUMBER,
    MAXIMUM_ELEVATION NUMBER,
    ORIG_ELEV_UNITS VARCHAR2(30),
    MIN_DEPTH NUMBER,
    MAX_DEPTH NUMBER,
    DEPTH_UNITS VARCHAR2(30),
    MAX_ERROR_DISTANCE NUMBER,
    MAX_ERROR_UNITS VARCHAR2(30),
    DATUM VARCHAR2(255),
    LOCALITY_REMARKS VARCHAR2(4000),
    georeference_source VARCHAR2(4000),
    georeference_protocol VARCHAR2(255),
    locality_name VARCHAR2(255)
);

ALTER TABLE locality ADD CONSTRAINT pk_locality PRIMARY KEY (locality_id) USING INDEX TABLESPACE UAM_IDX_1;
ALTER TABLE locality add CONSTRAINT fk_locality_geogauthrec FOREIGN KEY (GEOG_AUTH_REC_ID) REFERENCES GEOG_AUTH_REC (GEOG_AUTH_REC_ID);
ALTER TABLE locality add CONSTRAINT fk_locality_ctelevunit FOREIGN KEY (ORIG_ELEV_UNITS) REFERENCES ctORIG_ELEV_UNITS (ORIG_ELEV_UNITS);	
ALTER TABLE locality add CONSTRAINT fk_locality_ctdepthunit FOREIGN KEY (DEPTH_UNITS) REFERENCES ctDEPTH_UNITS (DEPTH_UNITS);		   
ALTER TABLE locality add CONSTRAINT fk_locality_ctmerrunit FOREIGN KEY (MAX_ERROR_UNITS) REFERENCES ctMAX_ERROR_UNITS (MAX_ERROR_UNITS);	  
ALTER TABLE locality add CONSTRAINT fk_locality_ctdatum FOREIGN KEY (DATUM) REFERENCES ctDATUM (DATUM);		       
ALTER TABLE locality add CONSTRAINT fk_locality_ctgprotocl FOREIGN KEY (georeference_protocol) REFERENCES ctgeoreference_protocol (georeference_protocol);		     

        
-- FOR THE purposes OF getting THE major changes Implemented, skip datum transformation FOR now. This IS evil AND should become a priority,
-- it's just less evil than not loading coordinates


---------- NEW TABLE locality - NOT THE OLD ONE!!!

 INSERT INTO locality (
    locality_id,
    GEOG_AUTH_REC_ID,
    SPEC_LOCALITY,
    DEC_LAT,
    DEC_LONG,
    MINIMUM_ELEVATION,
    MAXIMUM_ELEVATION,
    ORIG_ELEV_UNITS,
    MIN_DEPTH,
    MAX_DEPTH,
    DEPTH_UNIT,
    MAX_ERROR_DISTANCE,
    MAX_ERROR_UNITS,
    DATUM,
    LOCALITY_REMARKS,
    georeference_source,
    georeference_protocol,
    locality_name
) (
    SELECT
        new_locality_id,
        GEOG_AUTH_REC_ID,
        SPEC_LOCALITY,
        DEC_LAT,
        DEC_LONG,
        MINIMUM_ELEVATION,
        MAXIMUM_ELEVATION,
        ORIG_ELEV_UNITS,
        MIN_DEPTH,
        MAX_DEPTH,
        DEPTH_UNIT,
        MAX_ERROR_DISTANCE,
        MAX_ERROR_UNITS,
        DATUM,
        LOCALITY_REMARKS,
        LAT_LONG_REF_SOURCE,
        GEOREFMETHOD
    FROM
        everything_locality
    GROUP BY
        new_locality_id,
        GEOG_AUTH_REC_ID,
        SPEC_LOCALITY,
        DEC_LAT,
        DEC_LONG,
        MINIMUM_ELEVATION,
        MAXIMUM_ELEVATION,
        ORIG_ELEV_UNITS,
        MIN_DEPTH,
        MAX_DEPTH,
        DEPTH_UNIT,
        MAX_ERROR_DISTANCE,
        MAX_ERROR_UNITS,
        DATUM,
        LOCALITY_REMARKS,
        LAT_LONG_REF_SOURCE,
        GEOREFMETHOD
);
    
---------- NEW TABLE collecting_event - NOT THE OLD ONE!!!

INSERT INTO collecting_event (
    COLLECTING_EVENT_ID,
    LOCALITY_ID,
    VERBATIM_DATE,
    VERBATIM_LOCALITY,
    COLL_EVENT_REMARKS,
    BEGAN_DATE,
    ENDED_DATE,
    LAT_DEG,
    DEC_LAT_MIN,
    LAT_MIN,
    LAT_SEC,
    LAT_DIR,
    LONG_DEG,
    DEC_LONG_MIN,
    LONG_MIN,
    LONG_SEC,
    LONG_DIR,
    DEC_LAT,
    DEC_LONG,
    DATUM,
    UTM_ZONE,
    UTM_EW,
    UTM_NS,
    ORIG_LAT_LONG_UNITS
   ) ( SELECT
    new_COLLECTING_EVENT_ID,
    LOCALITY_ID,
    VERBATIM_DATE,
    VERBATIM_LOCALITY,
    COLL_EVENT_REMARKS,
    BEGAN_DATE,
    ENDED_DATE,
    LAT_DEG,
    DEC_LAT_MIN,
    LAT_MIN,
    LAT_SEC,
    LAT_DIR,
    LONG_DEG,
    DEC_LONG_MIN,
    LONG_MIN,
    LONG_SEC,
    LONG_DIR,
    DEC_LAT,
    DEC_LONG,
    DATUM,
    UTM_ZONE,
    UTM_EW,
    UTM_NS,
    ORIG_LAT_LONG_UNITS
    FROM
    everything_locality
    GROUP BY
    COLLECTING_EVENT_ID,
    LOCALITY_ID,
    VERBATIM_DATE,
    VERBATIM_LOCALITY,
    COLL_EVENT_REMARKS,
    BEGAN_DATE,
    ENDED_DATE,
    LAT_DEG,
    DEC_LAT_MIN,
    LAT_MIN,
    LAT_SEC,
    LAT_DIR,
    LONG_DEG,
    DEC_LONG_MIN,
    LONG_MIN,
    LONG_SEC,
    LONG_DIR,
    DEC_LAT,
    DEC_LONG,
    DATUM,
    UTM_ZONE,
    UTM_EW,
    UTM_NS,
    ORIG_LAT_LONG_UNITS
);

-------- specimen_events
INSERT INTO  SPECIMEN_EVENT (
    collection_object_id,
    collecting_event_id,
    assigned_by_agent_id,
    assigned_date,
    specimen_event_type,
    COLLECTING_METHOD,
    COLLECTING_SOURCE,
    VERIFICATIONSTATUS,
    habitat
) ( SELECT
    collection_object_id,
    new_collecting_event_id,
    nvl(DETERMINED_BY_AGENT_ID,0),
    nvl(DETERMINED_DATE,SYSDATE),
    specimen_event_type,
    COLLECTING_METHOD,
    COLLECTING_SOURCE,
    VERIFICATIONSTATUS,
    merged_habitat
    FROM
    everything_locality
    GROUP BY  
    collection_object_id,
    collecting_event_id,
    assigned_by_agent_id,
    assigned_date,
    specimen_event_type,
    COLLECTING_METHOD,
    COLLECTING_SOURCE,
    VERIFICATIONSTATUS,
    habitat
);